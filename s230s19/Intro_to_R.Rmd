---
title: "A Crash Course in R"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This lab provides a very brief introduction to `RStudio`, its user interface, some basic `R` programming, as well as a publishing extension known as `RMarkdown`.

## Accessing RStudio

In this class, RStudio may be accessed in two ways, either from a physical copy of the on your computer, or from the Grinnell RStudio server [https://rstudio.grinnell.edu/](https://rstudio.grinnell.edu/).  A physical copy of `RStudio` is already installed on each computer in this classroom as well as a few other labs on campus.  If you'd like to get RStudio on your personal computer you simply need to:

1. Download and install `R` from [http://www.r-project.org/](http://www.r-project.org/)
2. Download and install `RStudio` from [http://www.rstudio.com/](http://www.rstudio.com/)

`R` and `Rstudio` are open-source software and completely free to download and use; so there is little downside to adding to your personal computer.

## The Layout of RStudio

When you open `RStudio` the first thing you'll want to do is open a file to work in. You can do this by navigating: File -> New File -> RScript. This will open a new window in the top left of the `RStudio` user interface for you to work in.  At this point you should see four panels:

1. Your RScript (top left)
2. The Console (bottom left)
3. Your Environment (top right)
4. The Files/Plots/Help viewer (bottom right)

The *RScript* is similar to a textfile and stores your code while you work on it.  At anytime you can send some or all of the code in your *RScript* to the *Console* for the computer to execute.  You can also type commands directly into the *Console*.  The *Console* will echo any code you tell it to run and display any textual/numeric output that the code generates.

The *Environment* shows you the names of datasets, variables, and user-created functions that have been loaded into your workspace and can be accessed by your code.  The *Files/Plots/Help Viewer* will display graphics generated by your code.  On the Grinnell RStudio Server it will also allow you to conveniently access files (such as labs or data sets) that are stored on the server. 

## Using R

`R` is an interpreted language, which allows you to have the computer execute any piece of the code in your *RScript* at any time.  
To run a piece of code simply highlight it and hit *Ctrl-Enter*, you should see the code that you ran appear in the *Console*, along with the response generated by the code.

## R as a Calculator

At its most basic level, `R` can be used to perform arithmetic operations.  A few examples are shown below, try typing them into your *RScript* and executing them on your own.

```{r}
4 + 6 - (24/6)
```

```{r}
5 ^ 2 + 2 * 2
```

Some arithmetic operations require the use of *functions*.  In the example below, the function "exp" raises the number $e$ to the power that is input into the function.  The input is given in the parentheses. In this example, the number 2 is input into the function "exp":

```{r}
exp(2)
```

This function takes the square root:

```{r}
sqrt(4)
```

This function takes the absolute value:

```{r}
abs(-1)
```


## Including Comments

Often in programming languages, you can provide comments within code to explain what the code does or leave notes for yourself. In `R`, the character "#" is used to start a comment.  Everything on the same line immediately to the right of the "#" will not be executed if submitted to the *console*.

```{r}
# This entire line is a comment and will do nothing if run
```

```{r}
1:6 # The command "1:6" appears before this comment
```

In your *RScript*, comments appear in green. You also should remember that the "#" starts a comment *only for a single line* of your RScript.

## Objects and Assignment

`R` allows you to store things in *objects*, which can later be referenced or used as inputs to functions:

```{r}
x <- 5 # This assigns the integer value '5' to the variable called 'x'
x^2    # We can now reference 'x'
```

`R` stores sequences in objects called *vectors*:

```{r}
x <- 1:3 # The sequence {1, 2, 3} is assigned to the vector called 'x'
print(x)
y <- c(1,2,3) # The function 'c' concatenates arguments (seperated by commas) into a vector
print(y)
z <- c("A","B","C") # Vectors can contain many types of values
print(z)
```

Data is typically stored in objects called *data.frames*, which are comprised of several vectors of the same length:

```{r}
DF <- data.frame(x = x, y = y, z = z) # Creates a data.frame object 'DF'
print(DF)
```

Note that `R` is case sensitive, meaning the lower case 'x' is a different object than the upper case 'X'.

## Indexing

Suppose we setup a vector 'x' and would like to extract the element in its second position and store it in a new object called 'b':

```{r}
x <- 5:10
b <- x[2]
b
```

The square brackets indicate we want to access a certain position (or multiple positions) within 'x'.

For some objects, such as data.frames, multiple dimensions are needed to specify an element's position:

```{r}
DF <- data.frame(x = x, y = y, z = z) 
DF[2,3] # The element in row 2, column 3
```

## Reading in Data

There are many ways to get data into `R`. If a data set is stored somewhere on your computer as a .csv file, you can load it using the R function `read.csv`:

```{r}
# my.data <- read.csv("H://path_to_my_data/my_data.csv")
```

`read.csv` is also capable of reading .csv files stored on the web. All of the datasets that you'll need for this class are stored on my personal website. The example below reads the data set IowaCityHomeSales.csv and stores it as an object called 'my.data':

```{r}
my.data <- read.csv("https://remiller1450.github.io/data/IowaCityHomeSales.csv")
```

We can check to see the data were read in correctly:

```{r, eval = FALSE}
head(my.data)  # This function prints the first several rows of an object
```

When working with a newly loaded dataset there are a few things we might want to know about the object storing the data:

```{r}
dim(my.data) # prints the dimensions of 'my.data'
nrow(my.data) # prints the number of rows of 'my.data'
ncol(my.data) # prints the number of columns of 'my.data'
colnames(my.data) # prints the sames of the variables (columns) of 'mydata'
```

## Variable Types

Most of the data we'll work will contain one of two types of variables, *numeric* variables (ie: 'sale.amount') or *factor* variables (ie: 'bsmt').  If you're ever unsure of a variable's type you can check it using `data.class`:

```{r}
data.class(my.data$sale.amount)
data.class(my.data$bsmt)
```

Occassionally we might need to use *logical* variables, in `R` these take on values of "TRUE" or "FALSE" and have several uses.  Logical variables can be created using *logical conditions*:

```{r}
x <- (1 > 3)
x
data.class(x)
```

## Subsetting Data

Suppose we want to access a single variable in our data set, there are a few different ways we can do so:

```{r}
sale.price1 <- my.data$sale.amount # The $ accesses the variable 'sale.amount' within 'my.data'
sale.price2 <- my.data[,1] # We can also use indexing to access 'sale.amount'
# Notice how we specified second dimension of 'my.data' (its columns)
head(sale.price1)
head(sale.price2)
```

Suppose we want to access a single case (subject) in our dataset:

```{r}
first.house <- my.data[1,] # This stores the entire first row
head(first.house)
```

## Logical Conditions and Subsetting

Suppose we want know which elements of sale.amount are larger than \$200,000:

```{r, eval = FALSE}
my.data$sale.amount > 200000 # Logical vector for the condition "> 200000"
which(my.data$sale.amount > 200000) # Positions of elements where the condition is "TRUE"
```

Some useful logical operators include:

\begin{center}
\begin{tabular}{l | c }
Operator & Description \\
\hline
$==$ & equal to \\
$!=$ & not equal to \\
$>$ & great than \\
$>=$ & greater than or equal to \\
$< $& less than \\
$<= $& less than or equal to \\
$\& $& and  \\
$| $& or  \\
$! $ & negation/not \\
\hline
\end{tabular}
\end{center}

Logical conditions are particularly useful for subsetting objects, here are a few examples:

```{r}
large.and.expensive <- my.data[my.data$sale.amount > 500000 & my.data$area.living > 3000,]
```

The example above creates a new object containing all homes that sold for more than \$ 500,000 and have living areas over 3,000 square feet.

```{r}
no.bsmt.or.no.ac <- my.data[my.data$bsmt == "None" | my.data$ac != "Yes",]
dim(no.bsmt.or.no.ac)
```

The example above creates a new object containing all homes that don't have a basement *or* don't have air conditioning

```{r}
no.bsmt.and.no.ac <- my.data[my.data$bsmt == "None" & my.data$ac != "Yes",]
dim(no.bsmt.and.no.ac)
```

The example above creates a new object containing homes that don't have a base *and* don't have air conditioning. Pay careful attention to the difference between this example and the prior example.

## Tables, Bar Charts and Histograms

One-way frequency tables summarize a single categorical (factor) variable, while two-way frequencies tables summarize the relationship between two categorical variables. Both of these summaries can be created by the "table" function:

```{r}
table(my.data$style) # A one-way frequency table of 'style'
table(my.data$bedrooms, my.data$bsmt) # A two-way frequency table of 'bedrooms' and 'bsmt'
# Notice that 'bedrooms' is stored as a numeric variable, 
# but it still can be used in the table function
```

Tables are their own type of object, they can be used by functions like "barplot":

```{r, fig.height= 3, fig.width= 4}
my.table <- table(my.data$bsmt) # Tables can be stored as objects
barplot(my.table) # Creates a bar plot from a table
```

We can construct basic visuals of numeric variables too:

```{r, fig.height= 3, fig.width= 4}
hist(my.data$sale.amount) # Histograms are for numeric variables
```

## Numeric Summaries

Below are some examples showing how to calculate some common summary statistics:

```{r}
mean(my.data$sale.amount) # mean
sd(my.data$sale.amount) # standard deviation
min(my.data$sale.amount) # minimum
max(my.data$sale.amount) # maximum
quantile(my.data$sale.amount, .35) # the 35th percentile
```

The `summary` function conveniently provides many of these statistics all at once:

```{r}
summary(my.data$sale.amount)
```

## Packages

To facilitate more complex tasks in `R` people have developed their own sets of functions known as *packages*.  If you are working on your own computer, packages will need to be installed:

```{r, eval = FALSE}
install.packages("ggplot2")
```

Once a package is installed it still needs to be loaded in order to be used.  You'll need to load a package every time you open `RStudio`, but you'll only need to install it once.

```{r, fig.height= 3, fig.width= 4}
library(ggplot2)
qplot(my.data$ac) # qplot is a function in the package ggplot2
```

If you are working on the Grinnell RStudio Server, you will be unable to install packages; however, almost all of the packages you'll are already installed on the server.

## RMarkdown

At the beginning of this document you were instructed to open a file called an "RScript". `RStudio` supports many other types of files, some of which are written in an authoring framework known as "RMarkdown".  RMarkdown conveniently allows you to both:

1. Save and execute `R` code
2. Generate high quality, reproducible reports that can be shared with an audience

To use RMarkdown you might need to install and load the package:

```{r, eval = FALSE}
install.packages("rmarkdown")
library("rmarkdown")
```

If you have the package installed and loaded, you'll be able to create RMarkdown files by selecting: File -> New File -> R Markdown. Go ahead and try this, hitting "Ok" to use the default options.

- Your new RMarkdown file should look a lot like an RScript.  The first thing you should notice is the header, which is initiated by three '-' characters and closed by another three '-' characters.  The header contains information that will appear at the top of your compiled report.
- The second thing you'll see is a block of code initiated by $\text{```\{r setup\}}$ and closed by $\text{```}$. This just sets up some options used when executing your `R` code when your report is built, for now you can ignore it.
- Next you'll see section headers defined by the $\#$ character. The number of $\#$ characters determines the level (size) of the header.
- Finally you'll see some blocks of code initiated by $\text{```\{r\}}$ and closed by $\text{```}$. These are bits of `R` code that can be executed by clicking on the green arrow in the upper right corner of the code box.  You can execute smaller pieces of code within these blocks by highlighting them and hitting *Ctrl-Enter*.

To compile your RMarkdown file into a polished report you need to "Knit" the file. You can do this by clicking on the "Knit" button (the yarn ball icon) located towards the upper left of screen.  

## More on RMarkdown

The information in the prior section provides a minimally sufficient introduction RMarkdown, I encourage you to go through the lessons created by RMarkdown's developers at [https://rmarkdown.rstudio.com/lesson-1.html](https://rmarkdown.rstudio.com/lesson-1.html) if you have the time.  These lessons include numerous screen shots, videos, and more detailed explanations of exactly how RMarkdown works and what it is capable of.

## On Your Own Questions

Directions:

1. Create a new RMarkdown file "HW1_MyName.Rmd" where "MyName" is replaced with your actual name. Title the document "Homework 1"
2. Write code blocks to address the following questions, label each block as "Question 1", "Question 2", etc. See the file "HW_Sample.Rmd" file if you need a template
3. Make sure your .Rmd file compiles (knits) and the formatting looks good
4. Submit via email both your .Rmd file and the .html file that it generates

### Option #1 (Questions 1 - 6)

**Question #1**

Write code that reads in the data file "CollegeData.csv", which is available at the url: "https://remiller1450.github.io/s209/CollegeData.csv", and stores the data as an object named "Dat".  

**Question #2**

Write code that finds the 20th percentile average four year tuition cost (ie: the 20th percentile of the variable "COSTT4_A"). Write a sentence describing (in non-statistical terms) what the 20th percentile means.

**Question #3**

Write code that creates a new vector named "log.sal" that is the log of the variable "AVGFACSAL" in the College Data.  Then use the `summary` function to provide a summary of the new variable.  Write a setence stating whether "log.sal" is approximately symmetric.

**Question #4**

Write code that creates a two-way frequency table using the variables "REGION" and "LOCALE". Write 1-2 sentences describing the relationship you see in the table.

**Question #5**

Use the `qplot` function in the package `ggplot2` to construct a plot of the variable "REGION".

**Question #6**

Write code that creates a new object named "Iowa.dat" that contains only colleges located in the state of Iowa (ie: the variable "STABBR" is "IA"). Print the dimensions of this new object.

### Option #2 (Questions 4 and 7)

**Question #4**

See Question 4 from the section above

**Question #7**

In `R` you can define your own functions.  The following code defines a function titled "position2", which accepts an object as its input (which is defined internally as "X") and returns the element in the second position:

```{r}
position2 <- function(X){
  out <- X[2]
  return(out)
}
position2(c("Q","R","S"))
```

The [trimmed (or truncated) mean](https://en.wikipedia.org/wiki/Truncated_mean) is a statistical measure of central tendency that removes a certain percentage of the highest and lowest observations (ie: the 10% trimmed mean uses the middle 80% of the data).  

For this question, write an `R` function named "trimmedmean" that accepts two arguments, a data vector "X" and a percentage "p", and returns the p% trimmed mean.  Then use your function to find the 5% trimmed mean of the variable "AVGFACSAL" from the College Data described in Question #1. (Hint: Use the function "sort" on your vector and then use logical conditions to subset it before taking its mean)